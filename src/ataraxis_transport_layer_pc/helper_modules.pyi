from enum import IntEnum
from typing import Any

import numpy as np
from _typeshed import Incomplete
from numpy.typing import NDArray as NDArray

_ZERO: Incomplete
_ONE_BYTE: int
_TWO_BYTE: int
_BYTE_SIZE: int

class COBSStatusCode(IntEnum):
    STANDBY = 11
    PAYLOAD_TOO_SMALL_ERROR = 12
    PAYLOAD_TOO_LARGE_ERROR = 13
    INVALID_PAYLOAD_DATATYPE_ERROR = 14
    PAYLOAD_ENCODED = 15
    PACKET_TOO_SMALL_ERROR = 16
    PACKET_TOO_LARGE_ERROR = 17
    DELIMITER_NOT_FOUND_ERROR = 18
    DELIMITER_FOUND_TOO_EARLY_ERROR = 19
    INVALID_PACKET_DATATYPE_ERROR = 20
    PAYLOAD_DECODED = 21

class _COBSProcessor:
    maximum_payload_size: int
    minimum_payload_size: int
    maximum_packet_size: int
    minimum_packet_size: int
    status: int
    def __init__(self) -> None: ...
    def encode_payload(self, payload: NDArray[np.uint8], delimiter: np.uint8) -> NDArray[np.uint8]: ...
    def decode_payload(self, packet: NDArray[np.uint8], delimiter: np.uint8) -> NDArray[np.uint8]: ...

class COBSProcessor:
    _processor: _COBSProcessor
    def __init__(self) -> None: ...
    def __repr__(self) -> str: ...
    def encode_payload(self, payload: NDArray[np.uint8], delimiter: np.uint8 = ...) -> NDArray[np.uint8]: ...
    def _resolve_encoding_status(self, payload: NDArray[np.uint8]) -> None: ...
    def decode_payload(self, packet: NDArray[np.uint8], delimiter: np.uint8 = ...) -> NDArray[np.uint8]: ...
    def _resolve_decoding_status(self, packet: NDArray[np.uint8]) -> None: ...
    @property
    def processor(self) -> _COBSProcessor: ...

class CRCStatusCode(IntEnum):
    STANDBY = 51
    DATA_BUFFER_DATATYPE_ERROR = 52
    CHECKSUM_CALCULATED = 53
    CHECKSUM_SERIALIZED = 54
    CHECKSUM_BUFFER_DATATYPE_ERROR = 55
    CHECKSUM_BUFFER_SIZE_ERROR = 56
    CHECKSUM_DESERIALIZED = 57

class _CRCProcessor:
    polynomial: np.uint8 | np.uint16 | np.uint32
    initial_crc_value: np.uint8 | np.uint16 | np.uint32
    final_xor_value: np.uint8 | np.uint16 | np.uint32
    crc_byte_length: np.uint8
    crc_table: Incomplete
    status: int
    def __init__(
        self,
        polynomial: np.uint8 | np.uint16 | np.uint32,
        initial_crc_value: np.uint8 | np.uint16 | np.uint32,
        final_xor_value: np.uint8 | np.uint16 | np.uint32,
    ) -> None: ...
    def calculate_crc_checksum(self, buffer: NDArray[np.uint8]) -> np.uint8 | np.uint16 | np.uint32: ...
    def serialize_checksum(self, crc_checksum: np.uint8 | np.uint16 | np.uint32) -> NDArray[np.uint8]: ...
    def deserialize_checksum(self, buffer: NDArray[np.uint8]) -> np.uint8 | np.uint16 | np.uint32: ...
    def _generate_crc_table(self, polynomial: np.uint8 | np.uint16 | np.uint32) -> None: ...
    def _make_polynomial_type(self, value: Any) -> np.uint8 | np.uint16 | np.uint32: ...

class CRCProcessor:
    _processor: _CRCProcessor
    def __init__(
        self,
        polynomial: np.uint8 | np.uint16 | np.uint32,
        initial_crc_value: np.uint8 | np.uint16 | np.uint32,
        final_xor_value: np.uint8 | np.uint16 | np.uint32,
    ) -> None: ...
    def __repr__(self) -> str: ...
    def calculate_crc_checksum(self, buffer: NDArray[np.uint8]) -> np.uint8 | np.uint16 | np.uint32: ...
    def _resolve_checksum_calculation_status(self, buffer: NDArray[np.uint8]) -> None: ...
    def serialize_checksum(self, crc_checksum: np.uint8 | np.uint16 | np.uint32) -> NDArray[np.uint8]: ...
    def _resolve_checksum_serialization_status(self) -> None: ...
    def deserialize_checksum(self, buffer: NDArray[np.uint8]) -> np.uint8 | np.uint16 | np.uint32: ...
    def _resolve_checksum_deserialization_status(self, buffer: NDArray[np.uint8]) -> None: ...
    @property
    def crc_byte_length(self) -> np.uint8: ...
    @property
    def crc_table(self) -> NDArray[np.uint8 | np.uint16 | np.uint32]: ...
    @property
    def processor(self) -> _CRCProcessor: ...
    @property
    def polynomial(self) -> np.uint8 | np.uint16 | np.uint32: ...
    @property
    def initial_crc_value(self) -> np.uint8 | np.uint16 | np.uint32: ...
    @property
    def final_xor_value(self) -> np.uint8 | np.uint16 | np.uint32: ...

class SerialMock:
    is_open: bool
    tx_buffer: bytes
    rx_buffer: bytes
    def __init__(self) -> None: ...
    def __repr__(self) -> str: ...
    def open(self) -> None: ...
    def close(self) -> None: ...
    def write(self, data: bytes) -> None: ...
    def read(self, size: int = 1) -> bytes: ...
    def reset_input_buffer(self) -> None: ...
    def reset_output_buffer(self) -> None: ...
    @property
    def in_waiting(self) -> int: ...
    @property
    def out_waiting(self) -> int: ...
